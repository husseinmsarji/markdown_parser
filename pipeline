# app/main.py
# Flask app for Cloud Run. Private service; Apps Script must present a Google-signed ID token (aud=Cloud Run URL).
# Cloud Run itself enforces auth; we just validate and process the JSON.

import logging
import os
from flask import Flask, jsonify, request, abort

from google.cloud import logging as cloud_logging
from tenacity import retry, stop_after_attempt, wait_exponential

from app.rag_pipeline import run_pipeline

# Cloud Logging setup
cloud_logging.Client().setup_logging(log_level=logging.INFO)
log = logging.getLogger("acronym-rag")

app = Flask(__name__)

@app.get("/healthz")
def healthz():
    return "ok", 200

@app.get("/ready")
def ready():
    required = ["PROJECT_ID", "GCS_BUCKET", "RAG_CORPUS_NAME"]
    missing = [k for k in required if not os.environ.get(k)]
    return ("ready", 200) if not missing else (f"missing env: {missing}", 500)

@retry(reraise=True, stop=stop_after_attempt(3), wait=wait_exponential(multiplier=1, min=1, max=10))
def _process(payload: dict) -> dict:
    return run_pipeline(payload)

@app.post("/ingest")
def ingest():
    # If Cloud Run is deployed with --no-allow-unauthenticated, all requests here already present a valid ID token
    # with aud=<service URL> and subject = the invoker service account. Cloud Run checks roles/run.invoker. :contentReference[oaicite:2]{index=2}
    try:
        payload = request.get_json(force=True, silent=False)
    except Exception:
        abort(400, "Invalid JSON body")
    if not isinstance(payload, dict):
        abort(400, "Payload must be a JSON object")

    try:
        result = _process(payload)
        return jsonify(result), 200
    except Exception as e:
        log.exception("Pipeline failure")
        abort(500, str(e))
